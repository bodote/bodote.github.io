<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-06T15:21:13+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Bodos Software Blog</title><subtitle>'Gedanken und Ideen zu Softwareentwicklung'</subtitle><author><name>Bodo Teichmann</name></author><entry><title type="html">Tdd Mit Angular</title><link href="http://localhost:4000/TDD-mit-Angular/" rel="alternate" type="text/html" title="Tdd Mit Angular" /><published>2020-11-06T00:00:00+00:00</published><updated>2020-11-06T00:00:00+00:00</updated><id>http://localhost:4000/TDD-mit-Angular</id><content type="html" xml:base="http://localhost:4000/TDD-mit-Angular/">&lt;h1 id=&quot;angular-tdd-workshop&quot;&gt;Angular TDD Workshop&lt;/h1&gt;
&lt;p&gt;Diese Angular-TDD-Workshop ist eine Variante von diesem &lt;a href=&quot;https://itnext.io/test-driven-development-in-an-angular-world-92c0c42a54d0&quot;&gt;Workshop&lt;/a&gt;
Wir verwende hier aber &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jasmine&lt;/code&gt; statt &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Jest&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;setup&quot;&gt;Setup&lt;/h2&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone git@github.com:bodote/tdd-angular.git 
git checkout v1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;aufgabe-1&quot;&gt;Aufgabe 1&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;füge eine Compomenten namens “favorite-movies” hinzu die eine Headline mit dem Titel “My Favorite Movies” anzeigt.&lt;/li&gt;
  &lt;li&gt;das heißt für TDD:  schreibe zuerst den Test  in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;favorite-movies.component.spec.ts&lt;/code&gt; und ergänze dannach das Template &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;favorite-movies.component.html&lt;/code&gt; bis der Test grün ist.
    &lt;h2 id=&quot;aufgabe-2&quot;&gt;Aufgabe 2&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Angenommen die neue Componente hätte schon eine Liste der Movies bekommen (z.B. von der Parent-Component an die &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FavoriteMoviesComponent&lt;/code&gt;, in dem dessen property mit einem &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Input()&lt;/code&gt; Decorator versehen wird, oder auch durch einen Service), teste, dass diese auch angezeigt werden.&lt;/li&gt;
  &lt;li&gt;Tip: wenn  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;describe&lt;/code&gt; oder &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;it&lt;/code&gt; umbenannt wird in  &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fdescribe&lt;/code&gt; oder &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fit&lt;/code&gt;  werden  &lt;strong&gt;NUR&lt;/strong&gt; diese ausgeführt und vor allem sieht man auch die gerenderte Ausgabe des jeweiligen TestBeds in Browser!&lt;/li&gt;
  &lt;li&gt;Anmerkung: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Input()&lt;/code&gt; vor der &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;favoriteMovies&lt;/code&gt; property der Klasse &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FavoriteMoviesComponent&lt;/code&gt; ist für den Unittest unnötig, geht auch ohne
    &lt;h2 id=&quot;aufgabe-3&quot;&gt;Aufgabe 3&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;nehmen wir an die &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;favoriteMovies&lt;/code&gt; sollen durch einen &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; asynchron bereit gestellt werden. Teste ob der Service richtig verwendet wird. Dazu den Service “mocken” und prüfe ob er richtig aufgerufen wurde.&lt;/li&gt;
  &lt;li&gt;refactore den gesamten Code, sodass auch die ersten 2 Tests wieder laufen&lt;/li&gt;
  &lt;li&gt;Zusatzfrage: kann man die Componente FavoriteMoviesComponent so bauen , dass sie automatisch &lt;strong&gt;entweder&lt;/strong&gt; mit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Input()&lt;/code&gt; Decorator &lt;strong&gt;oder&lt;/strong&gt; mit dem &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Service&lt;/code&gt; funktioniert? Wenn ja wie ?&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;lösungen&quot;&gt;Lösungen&lt;/h2&gt;
&lt;p&gt;sind &lt;a href=&quot;https://github.com/bodote/tdd-angular&quot;&gt;hier&lt;/a&gt; zu finden und zwar je Aufgabe ein git-Tag:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Aufgabe 1 &amp;lt;=&amp;gt; v1.0,&lt;/li&gt;
  &lt;li&gt;Aufgabe 2 &amp;lt;=&amp;gt; v1.2, z.B.: &lt;a href=&quot;https://github.com/bodote/tdd-angular/tree/v1.2&quot;&gt;Lösung zu Aufgabe 2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Aufgabe 3 &amp;lt;=&amp;gt; v1.3,&lt;/li&gt;
  &lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Bodo Teichmann</name></author><summary type="html">Angular TDD Workshop Diese Angular-TDD-Workshop ist eine Variante von diesem Workshop Wir verwende hier aber jasmine statt Jest Setup git clone git@github.com:bodote/tdd-angular.git git checkout v1.0 Aufgabe 1 füge eine Compomenten namens “favorite-movies” hinzu die eine Headline mit dem Titel “My Favorite Movies” anzeigt. das heißt für TDD: schreibe zuerst den Test in favorite-movies.component.spec.ts und ergänze dannach das Template favorite-movies.component.html bis der Test grün ist. Aufgabe 2 Angenommen die neue Componente hätte schon eine Liste der Movies bekommen (z.B. von der Parent-Component an die FavoriteMoviesComponent, in dem dessen property mit einem @Input() Decorator versehen wird, oder auch durch einen Service), teste, dass diese auch angezeigt werden. Tip: wenn describe oder it umbenannt wird in fdescribe oder fit werden NUR diese ausgeführt und vor allem sieht man auch die gerenderte Ausgabe des jeweiligen TestBeds in Browser! Anmerkung: @Input() vor der favoriteMovies property der Klasse FavoriteMoviesComponent ist für den Unittest unnötig, geht auch ohne Aufgabe 3 nehmen wir an die favoriteMovies sollen durch einen Service asynchron bereit gestellt werden. Teste ob der Service richtig verwendet wird. Dazu den Service “mocken” und prüfe ob er richtig aufgerufen wurde. refactore den gesamten Code, sodass auch die ersten 2 Tests wieder laufen Zusatzfrage: kann man die Componente FavoriteMoviesComponent so bauen , dass sie automatisch entweder mit @Input() Decorator oder mit dem Service funktioniert? Wenn ja wie ?</summary></entry><entry><title type="html">Literaturrecherche zu TDD</title><link href="http://localhost:4000/blog/Literaturrecherche-TDD/" rel="alternate" type="text/html" title="Literaturrecherche zu TDD" /><published>2020-10-12T00:00:00+00:00</published><updated>2020-10-12T00:00:00+00:00</updated><id>http://localhost:4000/blog/Literaturrecherche-TDD</id><content type="html" xml:base="http://localhost:4000/blog/Literaturrecherche-TDD/">&lt;h1 id=&quot;bücher&quot;&gt;Bücher:&lt;/h1&gt;
&lt;p&gt;Ich bin ja ein enthusiastischer Befürworter von Test Driven Design (TDD), insbesondere von dem “test first” Ansatz. Daher hat es mich einfach interessiert, was denn andere Autoren und auch (aber nicht nur) die wissenschaftliche Literatur zu dem Thema hergibt. Hier ist, was sich dazu gefunden habe:&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;aus-langlebige-softwarearchitekturen&quot;&gt;Aus &lt;a href=&quot;https://langlebige-softwarearchitekturen.de&quot;&gt;Langlebige Softwarearchitekturen&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;abschnitt-911&quot;&gt;Abschnitt 9.1.1:&lt;/h3&gt;

&lt;p&gt;&quot;Für Klassen, die in &lt;strong&gt;Zyklen&lt;/strong&gt; sind, existieren in den meisten Systemen
keine direkten Unit-Testklassen. Wollte man die Unit Tests programmieren, 
müsste man alle im Zyklus verflochtenen Klassen durch einen Mock
ersetzen oder Objekte von ihnen erzeugen. Das ist sehr viel Aufwand,
den die meisten Entwicklungsteams und Projektleiter scheuen.&quot;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;aus-test-driven-java-development---second-edition&quot;&gt;Aus &lt;a href=&quot;https://www.packtpub.com/product/test-driven-java-development-second-edition/9781788836111&quot;&gt;Test-Driven Java Development - Second Edition&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;kapitel-1--abschnitt-why-tdd&quot;&gt;Kapitel 1 , Abschnitt &quot;Why TDD?&quot;:&lt;/h3&gt;

&lt;p&gt;&quot;It's not an easy thing to master TDD. Even after learning all the
theory and going through best practices and anti-patterns, the journey
is only just beginning. &lt;strong&gt;TDD requires time and a lot of practice&lt;/strong&gt;. It's a
long trip that does not stop with this book. As a matter of fact, it
never truly ends. There are always new ways to become more proficient
and faster. However, even though the cost is high, the benefits are even
higher. &lt;strong&gt;People who have spent enough time with TDD claim that there is
no other way to develop a software.&lt;/strong&gt; We are one of them and we're sure
that you will be too.&quot;&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h1 id=&quot;wissenschaftliche_studien_zu_tdd&quot;&gt;Wissenschaftliche oder zumindest systematische Studien zu TDD&lt;/h1&gt;

&lt;h2 id=&quot;assessing-test-driven-development-at-ibm&quot;&gt;&lt;a href=&quot;https://collaboration.csc.ncsu.edu/laurie/Papers/MAXIMILIEN_WILLIAMS.PDF&quot;&gt;Assessing test-driven development at IBM&lt;/a&gt;:&lt;/h2&gt;

&lt;p&gt;“… we reduced our &lt;strong&gt;defect rate by about 50 percent&lt;/strong&gt; compared to a
similar system that was built using an ad-hoc unit testing approach. The
project completed on time with &lt;strong&gt;minimal development productivity impact.&lt;/strong&gt;
Additionally, the suite of automated unit test cases created via TDD is
a reusable and extendable asset that will continue to improve quality
over the lifetime of the software system. The test suite &lt;strong&gt;will be the basis for quality checks&lt;/strong&gt; 
and will serve as a quality contract between all members of the team.”&lt;/p&gt;

&lt;h2 id=&quot;evaluating-the-efficacy-of-test-driven-development-industrial-case-studies-microsoft&quot;&gt;&lt;a href=&quot;https://d1wqtxts1xzle7.cloudfront.net/36509027/fp17288-bhat.pdf?1423032149=&amp;amp;response-content-disposition=inline%3B+filename%3DEvaluating_the_Efficacy_of_Test_Driven_D.pdf&amp;amp;Expires=1599907639&amp;amp;Signature=RuaKEjh7AbrkimLa5LGjb6zOpojv18srJrYQO7ONLNjWm586g6nxlDjGnYgubwIFYYp5fNkQulFn6YD3wpvud5bBhvwkO4nOOFMYyhATLdvHjHtW3vzm6ncsuqgwYTIKtrxbxAd7lQiEiue~D300FsgSLK6ZUk9DOssTqS0NZry6syc9I6IQYR6H2BRcnzf9oxvCTBWPzjSEBPi2cqYpyKbF1Y322XtLj7fdNTu8IVkmUULxwH3R1GVsEZrdpOAOJpM0b1ZAsJZEI0K3hiv~ENiV79hUjoyRu5xLaDeDWA4Nhg4Q-J8Zu8UQ18hQEjl0dOZnq7o4Xq~2-8jbuzDxIQ__&amp;amp;Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA&quot;&gt;Evaluating the Efficacy of Test-Driven Development: Industrial Case Studies (Microsoft)&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;2,6-4,2 mal mehr Bugs , wenn KEIN TDD verwendet. oder anders
gerechnet &lt;strong&gt;Bugrate sinkt mit TDD um 62%-77%&lt;/strong&gt; .&lt;/li&gt;
  &lt;li&gt;15% -35% mehr Zeit für TDD notwendig.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;” The results summarized … indicate that while the development of
both the systems utilizing TDD took extra time upfront the &lt;strong&gt;resulting quality was higher&lt;/strong&gt; 
than teams that adopted a non-TDD approach by an
order of at least two times. “&lt;/p&gt;

&lt;h2 id=&quot;metastudie-die-6-unterschiedliche-studien-ausgewertet-hat-does-test-driven-development-really-improve-software-design-quality&quot;&gt;Metastudie, die 6 unterschiedliche Studien ausgewertet hat: &lt;a href=&quot;https://digitalcommons.calpoly.edu/cgi/viewcontent.cgi?article=1027&amp;amp;context=csse_fac&quot;&gt;Does Test-Driven Development Really Improve Software Design Quality?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;“… Our results indicate that &lt;strong&gt;test-first programmers&lt;/strong&gt; are more likely
to write software in more and smaller units that are &lt;strong&gt;less complex and more highly tested&lt;/strong&gt; ….”&lt;/p&gt;

&lt;h2 id=&quot;an-experimental-evaluation-of-the-effectiveness-and-efficiency-of-the-test-driven-development&quot;&gt;&lt;a href=&quot;https://ieeexplore.ieee.org/abstract/document/4343756&quot;&gt;An Experimental Evaluation of the Effectiveness and Efficiency of the Test Driven Development&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;“Our results suggest that &lt;strong&gt;TDD&lt;/strong&gt; helps in &lt;strong&gt;reducing overall development effort&lt;/strong&gt; 
and &lt;strong&gt;improving developer’s productivity&lt;/strong&gt; whereas the code quality
seems to be affected by the actual testing efforts applied during a
development-style.”&lt;/p&gt;

&lt;h2 id=&quot;metastudie-how-effective-is-test-driven-development&quot;&gt;Metastudie: &lt;a href=&quot;https://www.researchgate.net/profile/Burak_Turhan/publication/258126622_How_Effective_is_Test_Driven_Development/links/54e794320cf27a6de10a8afe/How-Effective-is-Test-Driven-Development.pdf&quot;&gt;How Effective is Test-Driven Development?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;“Is it for everyone?”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“One basic fact on which almost everyone agrees is that &lt;strong&gt;TDD is difficult to learn&lt;/strong&gt;. 
It involves a steep learning curve that requires skill,
maturity, and time, particularly when developers are entrenched in the
code-then-test paradigm. Better tool support for test-case generation
and early exposure in the classroom to a test-then-code mentality may
encourage TDD adoption.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;“Could it be addictive?”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“Personal communications with TDD developers suggest that it is an addictive practice. 
It &lt;strong&gt;changes the way people think&lt;/strong&gt; and their approach
to coding in a way that is difficult to roll back. Therefore, leaving
TDD practices may be as difficult as adopting them.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fazit: Empfehlung für TDD&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;comparing-the-defect-reduction-benefits-of--test-driven-development&quot;&gt;&lt;a href=&quot;http://ibiai.mg.gov.br/wp-content/uploads/2019/08/05750007-1.pdf&quot;&gt;Comparing the Defect Reduction Benefits of ... Test-Driven Development&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;“TDD has several purported benefits—only one of which is software
defect reduction … We found that &lt;strong&gt;code inspection [=review?] is more effective than TDD&lt;/strong&gt; 
at reducing defects, but that &lt;strong&gt;code inspection is also more expensive&lt;/strong&gt; 
to implement. We also found some evidence to indicate that TDD
may result in an implementation cost savings, …”&lt;/p&gt;

&lt;h2 id=&quot;test-driven-development&quot;&gt;&lt;a href=&quot;https://link.springer.com/book/10.1007%2F978-3-642-04288-1&quot;&gt;Test-Driven Development&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Empirical studies by Madeyski (Madeyski, 2010a) showed that TDD is
&lt;strong&gt;better&lt;/strong&gt; in producing &lt;strong&gt;loosely coupled&lt;/strong&gt; software in comparison with
traditional test last software development practice.&lt;/p&gt;

&lt;h1 id=&quot;sonstige-links&quot;&gt;Sonstige Links:&lt;/h1&gt;
&lt;h2 id=&quot;aus-large-scale-scrumless&quot;&gt;aus &lt;a href=&quot;https://less.works/de/less/technical-excellence/test-driven-development&quot;&gt;Large-Scale Scrum »LeSS«&lt;/a&gt;:&lt;/h2&gt;

&lt;p&gt;“We &lt;strong&gt;rarely&lt;/strong&gt; meet people who were able to adopt this by &lt;strong&gt;self-education&lt;/strong&gt;. Most developers &lt;strong&gt;need a coach&lt;/strong&gt; to pair-program with them for days or weeks.”&lt;/p&gt;

&lt;p&gt;und:&lt;/p&gt;

&lt;p&gt;“Test-driven development might be the &lt;strong&gt;hardest agile practice&lt;/strong&gt; to adopt, but it is also &lt;strong&gt;one of the biggest opportunities&lt;/strong&gt; for improving the quality of the design and code. “&lt;/p&gt;

&lt;p&gt;und weiter:&lt;/p&gt;

&lt;p&gt;“TDD can help improve the architecture of a system. How?&lt;/p&gt;

&lt;p&gt;When we are coaching, a frequent request is help for dealing with our client’s “inflexible architecture.” This most often boils down to problems in &lt;strong&gt;high coupling between components&lt;/strong&gt; —a common problem in legacy code written &lt;strong&gt;without TDD&lt;/strong&gt; because the original developer did not try to test the component in isolation.&lt;/p&gt;

&lt;p&gt;On the other hand, when a developer creates a new component (such as a class) &lt;strong&gt;with TDD&lt;/strong&gt;, or refactors a legacy component to be unit-testable, they must break the dependencies of that component so that it is testable in isolation. That requires &lt;strong&gt;designing (or refactoring) for dependency&lt;/strong&gt; injection and &lt;strong&gt;increased use of mechanisms for flexibility&lt;/strong&gt;: interfaces, polymorphism, design patterns, dependency injection frameworks, function pointers, and more.&lt;/p&gt;

&lt;p&gt;In this way, &lt;strong&gt;TDD&lt;/strong&gt; encourages &lt;strong&gt;lower coupling&lt;/strong&gt; and simple, flexible configuration—qualities of a &lt;strong&gt;good architecture.&lt;/strong&gt;”&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Fußnoten:&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Angeregt wurde ich dazu übrigens, als ich das Buch &lt;a href=&quot;https://langlebige-softwarearchitekturen.de&quot;&gt;Langlebige Softwarearchitekturen&lt;/a&gt; von Carola Lilienthal las. Sie hat nämlich an einige Stellen auf auf systematische Studien verwiesen, die Ihre jeweilige Aussagen im Buch belegen sollen. Übrigens schreibt sie auch sehr positiv über TDD in dem Buch, wie man hier gleich in der ersten Fundstelle sieht. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Ich hoffe, wir sind uns einig, dass Zyklen, egal ob auf
Modul/Package-Ebene oder auf Ebene von Klassen innerhalb eines
Packages böse sind. Daher, heißt das 
im Umkehrschluss: wenn ich mit TDD anfange, kann mir das
nicht passieren. Im Gegenteil: TDD hindert mich direkt daran, solche
Fehler zu machen und zwingt mich, vor schreiben von Classen und
Methode mir Gedanken über die Microarchitektur (also die Architektur
von Klassen, die zu einem Bounded Context gehören, die zu einem
Package gehören oder sonst eng zusammengehören.) &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;den fett gedruckte Satz kann ich aus eigener Erfahrung bestätigen. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Bodo Teichmann</name></author><category term="TDD" /><category term="Test Driven Development" /><summary type="html">Bücher: Ich bin ja ein enthusiastischer Befürworter von Test Driven Design (TDD), insbesondere von dem “test first” Ansatz. Daher hat es mich einfach interessiert, was denn andere Autoren und auch (aber nicht nur) die wissenschaftliche Literatur zu dem Thema hergibt. Hier ist, was sich dazu gefunden habe:1 Angeregt wurde ich dazu übrigens, als ich das Buch Langlebige Softwarearchitekturen von Carola Lilienthal las. Sie hat nämlich an einige Stellen auf auf systematische Studien verwiesen, die Ihre jeweilige Aussagen im Buch belegen sollen. Übrigens schreibt sie auch sehr positiv über TDD in dem Buch, wie man hier gleich in der ersten Fundstelle sieht. &amp;#8617;</summary></entry><entry><title type="html">TDD? aber richtig!</title><link href="http://localhost:4000/blog/TDD-aber-richtig/" rel="alternate" type="text/html" title="TDD? aber richtig!" /><published>2020-10-09T00:00:00+00:00</published><updated>2020-10-09T00:00:00+00:00</updated><id>http://localhost:4000/blog/TDD-aber-richtig</id><content type="html" xml:base="http://localhost:4000/blog/TDD-aber-richtig/">&lt;h1 id=&quot;warumtddundtest-first&quot;&gt;Warum »TDD« und »Test First« ?&lt;/h1&gt;

&lt;p&gt;Vorweg eine Frage: Sind wir uns eigentlich einig, dass Unittests mit angemessener
Testabdeckung sehr wünschenswert sind ? (Wobei es mir hier tatsächlich erstmal &lt;strong&gt;nur&lt;/strong&gt;
um Unittests geht, nicht um Integrationstests oder um Akzeptanztests oder der
gleichen)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Wenn ja: Gut, dann haben wir diese Hürde ja schon mal aus dem Weg geräumt.&lt;/li&gt;
  &lt;li&gt;Wenn nein: Weil Ihr Unittests nicht für wichtig hälst oder das  das Messen der Testabdeckung ? &lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;was-genau-sindunittests&quot;&gt;Was &lt;strong&gt;GENAU&lt;/strong&gt; sind »Unittests« ??&lt;/h2&gt;

&lt;p&gt;Mit Unittests meine ich hier immer “White Box” - Tests,  die außerdem immer automatisiert sind.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Whiteboxtest heißt ja: derjenige, der den Test schreibt oder plant,  kennt immer auch die Internas der zu testenden Klasse(n) (andernfalls wäre es ja ein “Black-Box-Test”)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;testabdeckung-ist-sehr-wichtig-richtig-&quot;&gt;Testabdeckung ist sehr wichtig, richtig ?&lt;/h2&gt;
&lt;p&gt;Na ja, ich halte die Testabdeckung im Sinn von ‘x %’ der Codezeilen ehr für fast nebensächlich. Weil, wenn Ihr sie als Hauptkriterium für die Qualität der Tests missverstehst, da bin ich wirklich anderer Meinung. Ich kann euch nämlich mühelos eine 100% Testabdeckung erzielen, ohne dass ich auch nur jemals einen Fehler damit finde. Wie? Indem ich einfach alle “assert…” Statements im Unittest vergesse.&lt;/p&gt;

&lt;h2 id=&quot;was-isttest-driven-development&quot;&gt;Was ist »Test Driven Development« ?&lt;/h2&gt;
&lt;p&gt;Mit geht es hier um TDD im Sinne von z.B.  dem Buch “&lt;a href=&quot;https://www.packtpub.com/product/test-driven-java-development-second-edition/9781788836111&quot;&gt;Test Driven Java Development&lt;/a&gt;”.&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; Gibt natürlich viele andere Bücher Tutorials und ONline-Kurse zum Thema.&lt;/p&gt;

&lt;p&gt;Also das wichtige und entscheidende ist für mich das  &lt;strong&gt;TEST FIRST&lt;/strong&gt; Prinzip. Daher kommt ja auch das &lt;strong&gt;DRIVEN&lt;/strong&gt; in TDD.&lt;/p&gt;

&lt;h1 id=&quot;test-first-ist-deswegen-entscheidend-weil&quot;&gt;»Test First«  ist deswegen entscheidend, weil…&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Test first&lt;/strong&gt; zwingt vor dem Schreiben des eigentlich Code und der eigentlichen Unittests dazu, sich sehr klar über die Anforderungen und das Softwaredesign und zwar auf Klassen/Interface- Ebene Gedanken zu machen.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test first&lt;/strong&gt; trägt dann fast automatisch zu einer klareren Softwarearchitektur auf Klassen/Interface- Ebene bei.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test zuerst&lt;/strong&gt; zu schreiben geht aber nur, wenn ich nicht nur die &lt;strong&gt;fachlichen&lt;/strong&gt; Anforderungen genau verstanden sondern, wenn ich auch genau verstanden habe wie sich mein neuer Code in den bestehenden einfügen soll. Ich bin also gezwungen, mir vor der ersten Codezeile die ich schreibe, mehr Gedanken zu machen.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test first&lt;/strong&gt;- Code braucht meiner Erfahrung nach weniger späteres  Refactoring (also Refactoring dessen Notwendigkeit erst in einem späteren Entwicklungszyklus oder in einem späteren Sprint offensichtlich wird)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test first&lt;/strong&gt; führt zu kleineren Klassen und Methoden, fördert automatisch das &lt;a href=&quot;https://de.wikipedia.org/wiki/Single-Responsibility-Prinzip&quot;&gt;Single-Responsibility-Prinzip&lt;/a&gt;, damit meine ich, kleinere Klassen und kleinere Methode die von weniger anderen Klassen abhängen. Ich hoffe euch ist klar, dass das was sehr gutes ist.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test first&lt;/strong&gt; spart am Ende halt doch Zeit und liefert höhere Code-Qualität.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;warum--so-häufig-test-last-statttest-first&quot;&gt;Warum  so häufig “test last” statt »Test First« ?&lt;/h2&gt;
&lt;p&gt;Also die Frage ist ja, warum wird “test last” so häufig praktiziert? obwohl man mit “test last” kaum die gerade genannte Vorteile erzielt.
Ich denke das liegt daran, dass …&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Test first&lt;/strong&gt; - zu denken halt erstmal sehr schwer zu lernen ist und es kostet einiges an Zeit um das zu lernen.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test first&lt;/strong&gt; lässt sich vor allem in altem Legacy-Code kaum nachträglich einführen und es macht schon gar keinen Sinn &lt;strong&gt;Test First&lt;/strong&gt; im Umfeld von altem Legacy-Code neu lernen zu wollen, das geht aus meiner Erfahrung schief. Ja und…&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test first&lt;/strong&gt; spielt leider in der Ausbildung oder Studium nach wie vor kaum eine Rolle, gleiches gilt für die meisten Fachbücher und Tutorials&lt;/li&gt;
  &lt;li&gt;also &lt;strong&gt;Test First&lt;/strong&gt; kann/muss  man daher leider also erst immer “zusätzlich” lernen, nachdem man die jeweilige Programmiersprache oder Framework schon quasi “falsch” nämlich “test last” gelernt hat. Das macht es Neulingen leider zusätzlich unnötig schwer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ich behaupte, wenn man jede neue Programmiersprache oder jedes neue Framework von vornherein mit &lt;strong&gt;Test First&lt;/strong&gt; lernen würden, würde es viel mehr praktiziert und wäre einfach viel selbstverständlicher.&lt;/p&gt;

&lt;p&gt;Jetzt könnt Ihr sagen: “Der Bodo kann uns viel erzählen, wo sind die Beweise?”&lt;/p&gt;
&lt;h1 id=&quot;beweise--beweise-&quot;&gt;Beweise , Beweise !&lt;/h1&gt;

&lt;p&gt;ok, beweisen im strengen mathematische Sinn lässt sich das nicht ohne weiteres. ABER: es gibt doch eine größere Zahl an &lt;a href=&quot;../Literaturrecherche-TDD&quot;&gt;Vergleichsstudien zum Thema TDD und andere interessante Zitate&lt;/a&gt;! die ich für euch recherchiert habe.&lt;/p&gt;

&lt;h1 id=&quot;meine-persönliche-erfahrung-mit-tdd&quot;&gt;Meine persönliche Erfahrung mit TDD:&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;es macht mir einfach viel mehr Spaß so zu programmieren&lt;/li&gt;
  &lt;li&gt;mit dem konsequenten “test first”-Ansatz von TDD ergibt sich ein
geringerer Zeitaufwand gegenüber nachträglich gebauten Unittests:
    &lt;ul&gt;
      &lt;li&gt;Weil ich dann während des Schreibens der eigentlichen
Klasse/Methode ja keine &lt;strong&gt;manuellen&lt;/strong&gt; Tests mehr mache.&lt;/li&gt;
      &lt;li&gt;Denn: wenn ich noch keinen Unittest habe, wie teste ich eine
Klasse/Methode die ich grad geschrieben oder verändert hat?
durch bloßes hinschauen (ist fehleranfällig) oder durch
manuelles Testen, das kostet jedes mal wieder Zeit!&lt;/li&gt;
      &lt;li&gt;Weil ich gedanklich praktisch gleichzeitig eigentlichen Code und TestCode erfinde, ich bin also beim Schreiben des Tests schon gedanklich in der Thematik drin bin.&lt;/li&gt;
      &lt;li&gt;Schreibe ich dagegen den Unittest erst später, dann muss ich
mich ja ins Thema erst wieder neu eindenken. Schlimmstenfalls
müsste ich sogar meine Klassen/Methoden-Design ändern, was ich
natürlich im nach hinein eher nicht mehr mache.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Ich habe keinen Zeitdruck mehr beim “nachziehen” von Test: leider ist es nicht selten, dass nachträglich geschriebene Unittests von mindere Qualität ist, obwohl doch die Testabdeckung-Metrik hoch ist, oder schlimmer, dass die Tests ganz “vergessen” werden, weil:
    &lt;ul&gt;
      &lt;li&gt;der Sprint schon vorbei ist&lt;/li&gt;
      &lt;li&gt;der PO oder der Kunden mit neuen Featurewünschen drängt&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Nochmal zur manchmal so heiligen &lt;strong&gt;Testabdeckung&lt;/strong&gt;: Ehrlich gesagt ist mir die komplett egal wenn ich “test first” mache ! Denn: ich weiß ja von vornherein, dass ich alle Methoden in allen Klassen, die auch nur minimale Logic enthalten, mit Unittests zu 100% abgedeckt habe. Ob die gesamte Testabdeckung dann bei 80, 90 oder 95 % liegt (weil halt Glue-Code ohne Logik und Setter/Getter nicht abgedeckt sind), ist doch dann komplett irrelevant.&lt;/li&gt;
  &lt;li&gt;Falls ich in meinen Unittests doch mal einen Fall vergessen habe, der dann im Integrationstest oder noch später aufgedeckt wird, dann und nur dann ziehe ich zuerst den Unittests nach und dann &lt;strong&gt;und erst da nach&lt;/strong&gt; fixe ich den eigentlichen Code.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tddunittest-finde-ich-sehr-schwer-wenn--&quot;&gt;TDD/Unittest finde ich sehr schwer, wenn  …&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;wenn es schon nennenswert Codeteile gibt, die ohne Unittests sind&lt;/li&gt;
  &lt;li&gt;und wenn gerade diese Codeteile geändert werden müssen&lt;/li&gt;
  &lt;li&gt;wenn es nicht einfach möglich ist, neue Features mit komplett neuen Klassen/Modulen zur realisieren, sondern alte Klassen erweitert
werden müssen.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;denn-unter-solchen-widrigen-randbedingungen&quot;&gt;Denn unter solchen widrigen Randbedingungen..&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;..ist TDD extrem mühsam: ich muss mich in Codeteile von anderen Entwicklern reindenken, ohne Unittests und ohne Doku. Das ist das doppelt schwer&lt;/li&gt;
  &lt;li&gt;und solchen Randbedingungen ist TDD extrem zeitaufwändig ohne vor allem ohne unmittelbaren Gewinn für PO und Kunden.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Übrigens: das heißt dann logischerweise auch, dass es keinen Sinn macht TDD an einem Projekt mit kaum Unittests &lt;strong&gt;neu lernen&lt;/strong&gt; zu wollen. Denn das geht ziemlich sicher schief.&lt;/p&gt;

&lt;p&gt;Wer sich an so einem “dicken Brett” mit TDD versuchen will, der muss
schon sehr TDD-Sattelfest sein und die Randbedingungen (Zeit, Geld)
müssen außerdem sehr optimal sein.&lt;/p&gt;

&lt;h2 id=&quot;wo-ich-tdd-schwierig-finde-es-aber-gerne-besser-machen-möchte&quot;&gt;Wo ich TDD schwierig finde, es aber gerne besser machen möchte&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;bei (Script) - Code, der direkt auf betriebssystemnahen Funktionen
operiert&lt;/li&gt;
  &lt;li&gt;beim Testen von Networking oder bei DB- Code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also , wenn es nur schwer gelingt, die externen Objekte (z.B.
betriebssystemnahen Funktionen) sinnvoll zu mocken.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Unittests sind gut und richtig, aber die Qualität von Unittest an der Testabdeckung zu messen halte ich für falsch. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Die Grundidee ist auch abseits von Java in anderen Programmiersprachen die gleiche. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Bodo Teichmann</name></author><category term="TDD" /><category term="Test Driven Development" /><summary type="html">Warum »TDD« und »Test First« ?</summary></entry><entry><title type="html">(Video)Test Driven Development und Test-First Tutorial</title><link href="http://localhost:4000/blog/TDD-Tutorial/" rel="alternate" type="text/html" title="(Video)Test Driven Development und Test-First Tutorial" /><published>2020-09-10T00:00:00+00:00</published><updated>2020-09-10T00:00:00+00:00</updated><id>http://localhost:4000/blog/TDD-Tutorial</id><content type="html" xml:base="http://localhost:4000/blog/TDD-Tutorial/">&lt;p&gt;Nach wie vor aktuell: Mein Tutorial zu Test Driven Development und Test-First&lt;/p&gt;

&lt;!-- Courtesy of embedresponsively.com //--&gt;

&lt;div class=&quot;responsive-video-container&quot;&gt;
    &lt;iframe src=&quot;https://www.youtube-nocookie.com/embed/8v4PixvHk18&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
  &lt;/div&gt;</content><author><name>Bodo Teichmann</name></author><category term="TDD" /><category term="Test Driven Development" /><summary type="html">Nach wie vor aktuell: Mein Tutorial zu Test Driven Development und Test-First</summary></entry></feed>